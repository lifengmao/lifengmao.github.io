---
title: 前端安全简述
date:  2017-12-01 21:30:00
categories:
- 通信/安全
tags: XSS CSRF
---

“安全”是个很大的话题，各种安全问题的类型也是种类繁多。如果我们把安全问题按照所发生的区域来进行分类的话，那么所有发生在后端服务器、应用、服务当中的安全问题就是“后端安全问题”，所有发生在浏览器、单页面应用、Web页面当中的安全问题则算是“前端安全问题”。本文主要讲述前端安全的相关方面知识。目前主流的前端攻击方法主要有以下两种：

* XSS:跨站脚本攻击（cross-site scripting）
* CSRF:跨站请求伪造（cross-site request forgery）

---

### XSS

XSS是跨站脚本攻击的简称，是目前主流的前端攻击方式。XSS发生的本质原因在于，恶意用户想浏览器输入带有script标签的代码并被浏览器错误的当成JavaScript脚本执行了。
XSS又可以根据其出现的方式分为以下两类：

* 反射型XSS：反射型XSS的特点是其XSS代码出现在URL中，然后提交给服务器，服务器将返回内容连带XSS代码一起发送给了客户端，最后被浏览器执行。
* 存储型XSS：存储型XSS过程大致与反射性类似，唯一的不同点在于存储型的XSS代码是存储在服务器端的。

根据XSS的特点，我们可以做以下几点防御：

* 对输入输出进行过滤和转义：比如说，我们可以限制用户输入带有"<"和">"的字符串，并且过滤掉含有“script”、“img”等能引起攻击的标签名称，就可以很好的限制XSS攻击。
* 在编写代码时不要使用eval、new Function等方法来操作字符串。
* 使用innerHTML，document.write的时候，如果数据是用户输入的，那么需要对关键字符都进行过滤与转义。
* 对于非客户端cookie，比如保存用户凭证的session，务必标识为http only，这样js就获取不到这个cookie值了，安全性得到提高。

---

### CSRF

CSRF全称是跨站请求伪造。简单来说，其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上。
CSRF的抵御方法的原理就是对跨域的请求进行限制，或者对用户的请求加上一些特殊标志。主要方法如下：

* 使用HTTP的REFERER标志来检测请求的页面是否是同域名
* 避免登录的session长时间储存在客户端
* 对用户的关键请求使用验证码或者token机制。其中token就是在服务器每次返回客户端页面的时候，在页面中埋入一个token字段，之后客户端请求的时候必须带上这个字段，从而让攻击者难以发起攻击。

---

### 其他常见的前端安全问题

#### iframe引发的问题

iframe这个标签真是让人又爱又恨。一方面，前端页面在需要用到第三方提供的页面组件时，使用iframe确实给我们的页面带来了很多便利；另一方面，很多前端攻击就是从iframe引发的。
首先，iframe总的内容是由第三方提供的，默认情况下它们是不受我们控制的，因此很难提防其中是否包含了恶意的JavaScript代码、flash插件和弹窗等，甚至iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了。
因此，HTML5中为iframe提供了一个sandbox的安全属性，通过它可以对iframe的行为进行各种限制。sandbox还忠实的实现了“Secure By Default”原则，也就是说，如果你只是添加上这个属性而保持属性值为空，那么浏览器将会对iframe实施史上最严厉的调控限制，基本上来讲就是除了允许显示静态资源以外，其他什么都做不了。比如不准提交表单、不准弹窗、不准执行脚本等等，连Origin都会被强制重新分配一个唯一的值，换句话讲就是iframe中的页面访问它自己的服务器都会被算作跨域请求。
关于sandbox的具体详情可以点击[这个网站](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)查看。
其次，利用iframe可以引起点击劫持攻击。攻击者将一个iframe插入到一个网站，比如说web页面小游戏的网站，然后利用z-index和opacity将这个iframe置于游戏页面的上方并完全透明，当你点击游戏页面时，实际上点击了攻击者植入的页面。
点击劫持的危害在于，攻击利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果只是迫使用户关注某个微博账号的话，看上去仿佛还可以承受，但是如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害可就难以承受了。
有多种防御措施都可以防止页面遭到点击劫持攻击，例如Frame Breaking方案。一个推荐的防御方案是，使用X-Frame-Options：DENY这个HTTP Header来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame中显示出来。

#### 本地的存储数据泄露
前端应用是完全暴露在用户以及攻击者面前的，在前端存储任何敏感、机密的数据，都会面临泄露的风险，就算是在前端通过JS脚本对数据进行加密基本也无济于事。
尽管有浏览器的同源策略限制，但是如果前端应用有XSS漏洞，那么本地存储的所有数据就都可能被攻击者的JS脚本读取到。如果用户在公用电脑上使用了这个前端应用，那么当用户离开后，这些数据是否也被彻底清除了呢？前端对数据加密后再存储看上去是个防御办法，但其实仅仅提高了一点攻击门槛而已，因为加密所用到的密钥同样存储在前端，有耐心的攻击者依然可以攻破加密这道关卡。

所以，在前端存储敏感、机密信息始终都是一件危险的事情，推荐的做法是尽可能不在前端存这些数据。

#### 对CDN进行攻击

出于性能考虑，前端应用通常会把一些静态资源存放到CDN（Content Delivery Networks）上面，例如Javascript脚本和Stylesheet文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。
如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，那么我们的前端应用拿到的就是有问题的JS脚本或者Stylesheet文件，使得攻击者可以肆意篡改我们的前端页面，对用户实施攻击。这种攻击方式造成的效果和XSS跨站脚本攻击有些相似，不过不同点在于攻击者是从CDN开始实施的攻击，而传统的XSS攻击则是从有用户输入的地方开始下手的。
防御这种攻击的办法是使用浏览器提供的SRI（Subresource Integrity）功能。顾名思义，这里的Subresource指的就是HTML页面中通过和元素所指定的资源文件。
每个资源文件都可以有一个SRI值，就像下面这样。它由两部分组成，减号（-）左侧是生成SRI值用到的哈希算法名，右侧是经过Base64编码后的该资源文件的Hash值。
浏览器在处理这个script元素的时候，就会检查对应的JS脚本文件的完整性，看其是否和script元素中integrity属性指定的SRI值一致，如果不匹配，浏览器则会中止对这个JS脚本的处理。

---

### 小结

本文简单描述了几种常见的前端攻击方式，其实浏览器厂商、W3C等已经做了很多的安全工作，只要我们合理的利用它们，就能很好的保护页面不受攻击。其中常见的有以下几种：

* HTTP响应头：我们可以设置X-Frame-Options来禁止页面被加载进iframe中，这样可以阻止大部分由iframe引发的攻击。我们还可以设置X-XSS-Protection对反射型XSS进行一些防御。最后还可以设置X-Content-Security-Policy来设置允许的资源来源以及对脚本执行环境进行控制。
* 对cookie设置HTTP ONLY。大部分前端攻击都是为了获取用户的cookie信息，因此对cookie设置限制可以避免cookie信息泄露。

最后，其实大部分前端攻击都是因为我们在写页面时滥用GET和POST请求引起的，因此我们要严格遵守规范使用GET和POST请求，并且不要使用JSONP来完成一些有可能引发危险的提交操作。

### 参考资料

[前端安全知多少](https://juejin.im/entry/598d6eb46fb9a03c3a25d2c1)
[8大前端安全问题（上）](http://web.jobbole.com/92875/)
[8大前端安全问题（下）](http://web.jobbole.com/92893/?utm_source=blog.jobbole.com&utm_medium=relatedPosts)